#!/usr/bin/env bash

# Change working directory
cd -- "$(
  dirname "${0}"
)"

# UI constants
COLOUR_NEGATIVE='\033[1;31m'
COLOUR_POSITIVE='\033[1;32m'
COLOUR_RESET='\033[0m'
CHARACTER_STEP='--->'
PREFIX_STEP=$(
	printf -- \
		'%s ' \
		"${CHARACTER_STEP}"
)
PREFIX_SUB_STEP=$(
	printf -- \
		' %s ' \
		"${CHARACTER_STEP}"
)
PREFIX_STEP_NEGATIVE=$(
	printf -- \
		'%b%s%b' \
		"${COLOUR_NEGATIVE}" \
		"${PREFIX_STEP}" \
		"${COLOUR_RESET}"
)
PREFIX_STEP_POSITIVE=$(
	printf -- \
		'%b%s%b' \
		"${COLOUR_POSITIVE}" \
		"${PREFIX_STEP}" \
		"${COLOUR_RESET}"
)
PREFIX_SUB_STEP_NEGATIVE=$(
	printf -- \
		'%b%s%b' \
		"${COLOUR_NEGATIVE}" \
		"${PREFIX_SUB_STEP}" \
		"${COLOUR_RESET}"
)
PREFIX_SUB_STEP_POSITIVE=$(
	printf -- \
		'%b%s%b' \
		"${COLOUR_POSITIVE}" \
		"${PREFIX_SUB_STEP}" \
		"${COLOUR_RESET}"
)

function scmi ()
{
	# Default settings
	local SCMI_COMMAND=""
	local SCMI_CHROOT_PATH="/"
	local SCMI_PACKAGE_NAME="scmi"
	local SCMI_INCLUDE_FILES="
	 environment.sh
	 default.sh
	 service-unit.sh
	"
	local SCMI_MANAGER_TYPE="docker"
	local SCMI_NAME=""
	local SCMI_NAME_FORMAT='{<name>|<name>.[group]}.<instance>.<node>'
	local SCMI_REGISTER_ENABLED=false
	local SCMI_TAG="latest"

	declare -a local SCMI_SETOPT

	# Abort if not run by root user or with sudo
	if [[ ${EUID} -ne 0 ]]; then
		scmi_error_message \
			"Run as root or use: sudo -E $(basename $0)"
		exit 1
	fi

	# Parse install options
	while [[ ${#} -gt 0 ]]; do
		case "${1}" in
			-h|--help)
				scmi_usage
				break
				;;
			-c)
				if [[ -z ${2:-} ]]; then
					scmi_error_message \
						"Empty option value (${1})"
					scmi_usage
				fi
				SCMI_CHROOT_PATH="${2}"
				shift 2
				;;
			--chroot=*)
				if [[ -z ${1#*=} ]]; then
					scmi_error_message \
						"Empty option value (${1})"
					scmi_usage
				fi
				SCMI_CHROOT_PATH="${1#*=}"
				shift 1
				;;
			-m)
				if [[ ${2:-} != docker ]] && [[ ${2:-} != systemd ]]; then
					scmi_error_message \
						"Empty option value (${1})"
					scmi_usage
				fi
				SCMI_MANAGER_TYPE=${2}
				shift 2
				;;
			--manager=*)
				if [[ ${1#*=} != docker ]] && [[ ${1#*=} != systemd ]]; then
					scmi_error_message \
						"Empty option value (${1})"
					scmi_usage
				fi
				SCMI_MANAGER_TYPE=${1#*=}
				shift 1
				;;
			-n)
				if [[ -z ${2:-} ]]; then
					scmi_error_message \
						"Empty option value (${1})"
					scmi_usage
				fi
				SCMI_NAME="${2}"
				shift 2
				;;
			--name=*)
				if [[ -z ${1#*=} ]]; then
					scmi_error_message \
						"Empty option value (${1})"
					scmi_usage
				fi
				SCMI_NAME="${1#*=}"
				shift 1
				;;
			-r|--register)
				SCMI_REGISTER_ENABLED=true
				shift 1
				;;
			--setopt=*)
				if [[ -z ${1#*=} ]]; then
					scmi_error_message \
						"Empty option value (${1})"
					scmi_usage
				fi
				SCMI_SETOPT+=("${1#*=}")
				shift 1
				;;
			-t)
				if [[ -z ${2:-} ]]; then
					scmi_error_message \
						"Empty option value (${1})"
					scmi_usage
				fi
				SCMI_TAG="${2}"
				shift 2
				;;
			--tag=*)
				SCMI_TAG="${1#*=}"
				shift 1
				;;
			-i|install)
				SCMI_COMMAND="install"
				shift 1
				;;
			-u|uninstall)
				SCMI_COMMAND="uninstall"
				shift 1
				;;
			*)
				scmi_error_message \
					"Unkown option or option expects a value (${1})"
				scmi_usage
				;;
		esac
	done

	if [[ -z ${SCMI_COMMAND} ]]; then
		scmi_usage
	fi

	if [[ -d ${SCMI_CHROOT_PATH} ]]; then
		export SCMI_CHROOT_PATH="${SCMI_CHROOT_PATH}"
	else
		scmi_error_message \
			"Invalid chroot path."
		exit 1
	fi

	# Let SCMI override values set in the environment.
	if [[ -n ${SCMI_NAME} ]]; then
		export DOCKER_NAME="${SCMI_NAME}"
	fi

	if [[ -n ${SCMI_TAG} ]]; then
		export DOCKER_IMAGE_TAG="${SCMI_TAG}"
	fi

	if [[ ${#SCMI_SETOPT[@]} -gt 0 ]]; then
		for OPT in "${SCMI_SETOPT[@]}"; do
			# Abort if operator attempts to set a --name option. 
			if [[ ${OPT} =~ ^--name.+$ ]]; then
				scmi_error_message \
					"Option conflict (--setopt=\"${OPT}\")"
				exit 1
			fi

			printf -v \
				DOCKER_CONTAINER_PARAMETERS_APPEND \
				-- '%s %s' \
				"${DOCKER_CONTAINER_PARAMETERS_APPEND}" \
				"$(
					sed \
						-e "s~{{NAME}}~${SCMI_NAME}~g" \
					<<< "${OPT}"
				)"
		done
	fi

	# Source include files
	for INCLUDE_FILE in ${SCMI_INCLUDE_FILES}; do
		if [[ -f ${INCLUDE_FILE} ]]; then
			source ${INCLUDE_FILE}
		elif [[ -f ../../opt/${SCMI_PACKAGE_NAME}/${INCLUDE_FILE} ]]; then
			source ../../opt/${SCMI_PACKAGE_NAME}/${INCLUDE_FILE}
		elif [[ -f /opt/${SCMI_PACKAGE_NAME}/${INCLUDE_FILE} ]]; then
			source /opt/${SCMI_PACKAGE_NAME}/${INCLUDE_FILE}
		fi
	done

	# Validate variable values
	if ! scmi_is_valid_managed_docker_name "${DOCKER_NAME}"; then
		scmi_error_message \
			"Invalid container name (${DOCKER_NAME})"
		printf -- \
			"${PREFIX_SUB_STEP} Please use the form: %s\n" \
			${SCMI_NAME_FORMAT}
		exit 1
	fi

	if [[ ! ${DOCKER_IMAGE_TAG} =~ ${DOCKER_IMAGE_TAG_PATTERN} ]]; then 
		scmi_error_message \
			"Invalid image tag (${DOCKER_IMAGE_TAG})"
		exit 1
	fi

	# Run command for selected service manager
	case ${SCMI_MANAGER_TYPE} in
		systemd)
			scmi_systemd_${SCMI_COMMAND}
			;;
		docker|*)
			scmi_docker_${SCMI_COMMAND}
			;;
	esac
}

function scmi_docker_create ()
{
	scmi_docker_require_container_not

	echo "${PREFIX_STEP} Creating container"

	(
		eval "set -x; \
			${docker} create \
			${DOCKER_CONTAINER_PARAMETERS} \
			${DOCKER_CONTAINER_PARAMETERS_APPEND} \
			${DOCKER_USER}/${DOCKER_IMAGE_NAME}:${DOCKER_IMAGE_TAG} \
			1> /dev/null;"
	)

	if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}" --filter "status=created") ]]; then
		echo "${PREFIX_SUB_STEP} $(${docker} ps -aq --filter "name=${DOCKER_NAME}" --filter "status=created")"
		echo "${PREFIX_SUB_STEP_POSITIVE} Container created"
	else
		echo "${PREFIX_SUB_STEP_NEGATIVE} Container creation failed"
		exit 1
	fi
}

function scmi_docker_install ()
{
	scmi_docker_prerequisites

	# Cleanup if interrupted, killed or on exit
	trap scmi_docker_install_cleanup \
		INT TERM EXIT

	scmi_docker_terminate
	scmi_docker_create
	scmi_docker_start

	trap - \
		INT TERM EXIT
}

function scmi_docker_install_cleanup ()
{
	scmi_docker_uninstall
	exit 1
}

function scmi_docker_prerequisites ()
{
	docker=''

	declare -a local DOCKER_PATHS=(
		'/usr/bin/docker'
		'/usr/local/bin/docker'
	)

	# Set the docker binary command
	if [[ ${SCMI_CHROOT_PATH} == / ]]; then
		if ! command -v docker &> /dev/null; then
			scmi_error_message \
				"Missing docker binary."
			exit 1
		fi

		printf -v \
			docker \
			-- '%s' \
			$(command -v docker)
	else
		for DOCKER_PATH in "${DOCKER_PATHS[@]}"; do
			if [[ -f ${SCMI_CHROOT_PATH%*/}${DOCKER_PATH} ]]; then
				printf -v \
					docker \
					-- 'chroot %s %s' \
					"${SCMI_CHROOT_PATH}" \
					${DOCKER_PATH}
				break
			fi
		done

		if [[ -z ${docker} ]]; then
			scmi_error_message \
				"Missing docker binary."
			exit 1
		fi
	fi

	# Test docker connection
	if [[ -z $(${docker} info) ]]; then
		scmi_error_message \
			"docker failed to connect to host."
		exit 1
	fi
}

# Deleting a container from host from a container that has the docker host's
# root directory volume mounted fails for CentOS hosts. To work around this
# issue we unmount the shm mount before calling docker rm.
function scmi_docker_release_host_mounted_container ()
{
	# Skip if not applicable case.
	if [[ -z ${SCMI_CHROOT_PATH} ]] \
		|| [[ ${SCMI_CHROOT_PATH} == / ]]; then
		return 0
	else
		scmi_docker_prerequisites

		if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}") ]]; then
			CONTAINER_ID=$(
				${docker} inspect --format="{{.Id}}" ${DOCKER_NAME}
			)
			CONTAINER_SHM_MOUNT=$(
				find \
					"${SCMI_CHROOT_PATH%*/}/var/lib/docker/containers/${CONTAINER_ID}" \
					-type d \
					-name "shm" \
					2> /dev/null
			)

			if [[ -n ${CONTAINER_ID} ]] && [[ -n ${CONTAINER_SHM_MOUNT} ]]; then
				printf -- \
					"${PREFIX_SUB_STEP} Unmounting container id: %s\n" \
					${CONTAINER_ID}

				umount "${SCMI_CHROOT_PATH%*/}/var/lib/docker/containers/${CONTAINER_ID}/shm"
			fi
		fi
	fi
}

function scmi_docker_require_container ()
{
	if [[ -z $(${docker} ps -aq --filter "name=${DOCKER_NAME}") ]]; then
		echo "${PREFIX_STEP_NEGATIVE} This operation requires the ${DOCKER_NAME} docker container."
		exit 1
	fi
}

function scmi_docker_require_container_not ()
{
	if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}") ]]; then
		echo "${PREFIX_STEP_NEGATIVE} This operation requires the ${DOCKER_NAME} docker container be removed (or renamed)."
		echo "${PREFIX_SUB_STEP} Try removing it with: docker rm -f ${DOCKER_NAME}"
		exit 1
	fi
}

function scmi_docker_require_container_not_status_paused ()
{
	if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}" --filter "status=paused") ]]; then
		echo "${PREFIX_STEP_NEGATIVE} This operation requires the ${DOCKER_NAME} docker container to be unpaused."
		echo "${PREFIX_SUB_STEP} Try unpausing it with: docker ${DOCKER_NAME} unpause"
		exit 1
	fi
}

function scmi_docker_start ()
{
	scmi_docker_require_container
	scmi_docker_require_container_not_status_paused

	echo "${PREFIX_STEP} Starting container"

	if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}") ]] \
		&& [[ -z $(${docker} ps -aq --filter "name=${DOCKER_NAME}" --filter "status=running") ]]; then
		${docker} start ${DOCKER_NAME} 1> /dev/null
	fi

	if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}" --filter "status=running") ]]; then
		echo "${PREFIX_SUB_STEP_POSITIVE} Container started"
	else
		echo "${PREFIX_SUB_STEP_NEGATIVE} Container start failed"
		exit 1
	fi
}

function scmi_docker_terminate ()
{
	if [[ -z $(${docker} ps -aq --filter "name=${DOCKER_NAME}") ]]; then
		echo "${PREFIX_STEP} Container termination skipped"
	else
		echo "${PREFIX_STEP} Terminating container"
		if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}" --filter "status=paused") ]]; then
			echo "${PREFIX_SUB_STEP} Unpausing container"
			${docker} unpause ${DOCKER_NAME} 1> /dev/null
		fi

		if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}" --filter "status=running") ]]; then
			echo "${PREFIX_SUB_STEP} Stopping container"
			${docker} stop ${DOCKER_NAME} 1> /dev/null
		fi

		if [[ -n $(${docker} ps -aq --filter "name=${DOCKER_NAME}") ]]; then
			echo "${PREFIX_SUB_STEP} Removing container"

			scmi_docker_release_host_mounted_container

			${docker} rm -f ${DOCKER_NAME} 1> /dev/null
		fi

		if [[ -z $(${docker} ps -aq --filter "name=${DOCKER_NAME}") ]] \
			&& [[ -z $(find ${SCMI_CHROOT_PATH%*/}/var/lib/docker/containers -type d -name "${CONTAINER_ID}" 2> /dev/null) ]]; then
			echo "${PREFIX_SUB_STEP_POSITIVE} Container terminated"
		else
			echo "${PREFIX_SUB_STEP_NEGATIVE} Container termination failed"
			exit 1
		fi
	fi
}

function scmi_docker_uninstall ()
{
	scmi_docker_prerequisites
	scmi_docker_terminate

	printf -- \
		"${PREFIX_SUB_STEP_POSITIVE} %s\n" \
		'Uninstall complete'
}

function scmi_error_message ()
{
	local MESSAGE="${1:-}"

	printf -- \
		"${PREFIX_STEP_NEGATIVE} ERROR: %s\n" \
		"${MESSAGE}"
}

# Require a docker name of the form described with SCMI_NAME_FORMAT
function scmi_is_valid_managed_docker_name ()
{
	local NAME="${1:-}"
	local NAME_PATTERN='^[a-zA-Z0-9][a-zA-Z0-9_.-]*\.[0-9][0-9]*\.[0-9][0-9]*$'

	if [[ -z ${NAME} ]]; then
		return 1
	fi

	if [[ ${NAME} =~ ${NAME_PATTERN} ]]; then
		return 0
	fi

	return 1
}

function scmi_systemd_get_unit_file_path ()
{
	local UNIT_FILE="${1:-}"
	local UNIT_FILE_PATH=""
	local TEMPLATE_PATHS="
	 .
	 ./etc/systemd/system
	 /etc/systemd/system
	"

	if [[ -z ${UNIT_FILE} ]]; then
		scmi_error_message \
			"Missing unit file name."
		exit 1
	fi

	for TEMPLATE_PATH in ${TEMPLATE_PATHS}; do
		if [[ -f ${TEMPLATE_PATH}/${UNIT_FILE} ]]; then
			UNIT_FILE_PATH=${TEMPLATE_PATH}/${UNIT_FILE}
			break
		fi
	done

	if [[ -z ${UNIT_FILE_PATH} ]]; then
		scmi_error_message \
			"Cannot locate unit file: ${UNIT_FILE}"
		exit 1
	fi

	printf -- \
		'%s' \
		"${UNIT_FILE_PATH}"
}

function scmi_systemd_install ()
{
	scmi_systemd_prerequisites

	# Cleanup if interrupted, killed or on exit
	trap scmi_systemd_install_cleanup \
		INT TERM EXIT

	printf -- \
		"${PREFIX_STEP} Installing %s\n" \
		${SERVICE_UNIT_INSTANCE_NAME}

	# Copy systemd unit-files into place.
	set -e
	cat \
		"$(scmi_systemd_get_unit_file_path "${DOCKER_IMAGE_NAME}@.service")" \
		> "${SCMI_CHROOT_PATH%*/}/etc/systemd/system/${SERVICE_UNIT_TEMPLATE_NAME}"
	set +e

	if [[ ${SCMI_REGISTER_ENABLED} == true ]]; then
		set -e
		sed \
			-e "s~{{SERVICE_UNIT_NAME}}~${SERVICE_UNIT_NAME}~g" \
			"$(scmi_systemd_get_unit_file_path "${DOCKER_IMAGE_NAME}.register@.service")" \
			> "${SCMI_CHROOT_PATH%*/}/etc/systemd/system/${SERVICE_UNIT_REGISTER_TEMPLATE_NAME}"
		set +e
	else
		# Remove register service unit template if found on host.
		if [[ -f ${SCMI_CHROOT_PATH%*/}/etc/systemd/system/${SERVICE_UNIT_REGISTER_TEMPLATE_NAME} ]]; then
			rm -f "${SCMI_CHROOT_PATH%*/}/etc/systemd/system/${SERVICE_UNIT_REGISTER_TEMPLATE_NAME}"
		fi
	fi

	# Create drop-in to set environment variables defined at install time.
	if [[ -n ${SERVICE_UNIT_ENVIRONMENT_KEYS} ]]; then

		printf \
			-v SYSTEMD_OVERRIDE_DIRECTORY \
			-- '%s/etc/systemd/system/%s.d' \
			"${SCMI_CHROOT_PATH%*/}" \
			"${SERVICE_UNIT_TEMPLATE_NAME}"

		SYSTEMD_OVERRIDE_FILE=10-override.conf

		mkdir -p "${SYSTEMD_OVERRIDE_DIRECTORY}"

		cat <<-EOF > "${SYSTEMD_OVERRIDE_DIRECTORY}/${SYSTEMD_OVERRIDE_FILE}"
		[Service]
		EOF

		# Set each key and value - escaping any % characters.
		for KEY in ${SERVICE_UNIT_ENVIRONMENT_KEYS}; do
			VALUE="${!KEY//%/%%}"

			# Allow variable expansion for DOCKER_CONTAINER_PARAMETERS_APPEND
			if [[ ${KEY} == DOCKER_CONTAINER_PARAMETERS_APPEND ]]; then
				printf \
					-- 'Environment="%s"\n' \
					"$(
						eval -- \
						echo \
							"${KEY}=${VALUE}"
					)" \
					>> "${SYSTEMD_OVERRIDE_DIRECTORY}/${SYSTEMD_OVERRIDE_FILE}"
			else
				printf \
					-- 'Environment="%s=%s"\n' \
					"${KEY}" \
					"${VALUE}" \
					>> "${SYSTEMD_OVERRIDE_DIRECTORY}/${SYSTEMD_OVERRIDE_FILE}"
			fi
		done

	fi

	${systemctl} daemon-reload
	${systemctl} enable -f ${SERVICE_UNIT_INSTANCE_NAME}
	if [[ ${SCMI_REGISTER_ENABLED} == true ]]; then
		${systemctl} enable -f ${SERVICE_UNIT_REGISTER_INSTANCE_NAME}
	elif ${systemctl} -q is-active ${SERVICE_UNIT_REGISTER_INSTANCE_NAME}; then
		${systemctl} disable -f ${SERVICE_UNIT_REGISTER_INSTANCE_NAME}
		${systemctl} stop ${SERVICE_UNIT_REGISTER_INSTANCE_NAME}
	fi

	scmi_docker_release_host_mounted_container

	${systemctl} restart ${SERVICE_UNIT_INSTANCE_NAME} &
	PIDS[0]=${!}

	# Tail the systemd unit logs unitl installation completes
	${journalctl} -fn 0 -u ${SERVICE_UNIT_INSTANCE_NAME} &
	PIDS[1]=${!}

	# Wait for installtion to complete
	[[ -n ${PIDS[0]} ]] && wait ${PIDS[0]}

	# Allow time for the container bootstrap to complete
	sleep ${SERVICE_UNIT_INSTALL_TIMEOUT}
	kill -15 ${PIDS[1]}
	wait ${PIDS[1]} 2> /dev/null

	if ${systemctl} -q is-active ${SERVICE_UNIT_INSTANCE_NAME} \
		&& ( \
			[[ ${SCMI_REGISTER_ENABLED} != true ]] \
			|| ${systemctl} -q is-active ${SERVICE_UNIT_REGISTER_INSTANCE_NAME} \
		); then

		printf -- \
			"${PREFIX_STEP} Service unit is active: %s\n" \
			"$(
				${systemctl} list-units --type=service \
				| grep "^[ ]*${SERVICE_UNIT_INSTANCE_NAME}"
			)"

		if [[ ${SCMI_REGISTER_ENABLED} == true ]]; then
			printf -- \
				"${PREFIX_STEP} Service register unit is active: %s\n" \
				"$(
					${systemctl} list-units --type=service \
					| grep "^[ ]*${SERVICE_UNIT_REGISTER_INSTANCE_NAME}"
				)"
		else
			printf -- \
				"${PREFIX_STEP} Service register unit is disabled (not installed)\n"
		fi

		printf -- \
			"${PREFIX_SUB_STEP_POSITIVE} %s\n" \
			'Install complete'
	else
		printf -- \
			"\nService status:\n"
		${systemctl} status -ln 50 ${SERVICE_UNIT_INSTANCE_NAME}
		printf -- \
			"\n${PREFIX_SUB_STEP_NEGATIVE} %s\n" \
			'Install error'
	fi

	trap - \
		INT TERM EXIT
}

function scmi_systemd_install_cleanup ()
{
	scmi_systemd_uninstall
	exit 1
}

function scmi_systemd_prerequisites ()
{
	local COMMAND
	declare -a local COMMAND_PATHS=(
		'/usr/bin/docker'
		'/usr/bin/systemctl'
		'/usr/bin/journalctl'
	)

	if [[ ${SCMI_CHROOT_PATH} == / ]]; then
		for COMMAND_PATH in "${COMMAND_PATHS[@]}"; do
			COMMAND=${COMMAND_PATH##*/}
			if ! command -v ${COMMAND} &> /dev/null; then
				scmi_error_message \
					"Missing required command: ${COMMAND_PATH}"
				exit 1
			fi

			printf -v \
				${COMMAND} \
				-- '%s' \
				${COMMAND_PATH}
		done
	else
		for COMMAND_PATH in "${COMMAND_PATHS[@]}"; do
			COMMAND=${COMMAND_PATH##*/}
			if [[ ! -f ${SCMI_CHROOT_PATH%*/}${COMMAND_PATH} ]]; then
				scmi_error_message \
					"Missing required command: ${COMMAND_PATH}"
				exit 1
			fi

			printf -v \
				${COMMAND} \
				-- 'chroot %s %s' \
				"${SCMI_CHROOT_PATH}" \
				${COMMAND_PATH}
		done
	fi

	scmi_systemd_set_service_unit_names
}

function scmi_systemd_set_service_unit_names ()
{
	SERVICE_UNIT_NAME=$(
		expr match \
			"${DOCKER_NAME}" \
			'\([^\.]*\.*[^\.]*\)\.[0-9][0-9]*\.[0-9][0-9]*'
	)
	SERVICE_UNIT_INSTANCE=$(
		expr match \
			"${DOCKER_NAME}" \
			'.*\.\([0-9][0-9]*\.[0-9][0-9]*\)'
	)

	SERVICE_UNIT_TEMPLATE_NAME=${SERVICE_UNIT_NAME}@.service
	SERVICE_UNIT_INSTANCE_NAME=${SERVICE_UNIT_NAME}@${SERVICE_UNIT_INSTANCE}.service

	SERVICE_UNIT_REGISTER_TEMPLATE_NAME=${SERVICE_UNIT_NAME}.register@.service
	SERVICE_UNIT_REGISTER_INSTANCE_NAME=${SERVICE_UNIT_NAME}.register@${SERVICE_UNIT_INSTANCE}.service
}

function scmi_systemd_uninstall ()
{
	scmi_systemd_prerequisites

	printf -- \
		"${PREFIX_STEP} Uninstalling %s\n" \
		${SERVICE_UNIT_INSTANCE_NAME}

	${systemctl} daemon-reload
	${systemctl} disable -f ${SERVICE_UNIT_INSTANCE_NAME} 2> /dev/null
	if [[ ! -n $(${systemctl} list-units --all type=service ${SERVICE_UNIT_INSTANCE_NAME} | grep '0 loaded units listed.') ]]; then
		${systemctl} stop ${SERVICE_UNIT_INSTANCE_NAME}
	fi

	${systemctl} disable -f ${SERVICE_UNIT_REGISTER_INSTANCE_NAME} 2> /dev/null

	# Before removing the template unit-files all units must first be disabled
	if [[ -n $(${systemctl} list-units --all type=service ${SERVICE_UNIT_NAME}@* | grep '0 loaded units listed.') ]]; then
		# Remove Drop-In file
		printf \
			-v SYSTEMD_OVERRIDE_DIRECTORY \
			-- '%s/etc/systemd/system/%s.d' \
			"${SCMI_CHROOT_PATH%*/}" \
			"${SERVICE_UNIT_TEMPLATE_NAME}"

		if [[ -d ${SYSTEMD_OVERRIDE_DIRECTORY} ]]; then
			rm -rf "${SYSTEMD_OVERRIDE_DIRECTORY}"
		fi

		# Remove systemd unit-files.
		for UNIT_FILE in ${SERVICE_UNIT_TEMPLATE_NAME} ${SERVICE_UNIT_REGISTER_TEMPLATE_NAME}; do
			if [[ -f ${SCMI_CHROOT_PATH%*/}/etc/systemd/system/${UNIT_FILE} ]]; then
				rm -f "${SCMI_CHROOT_PATH%*/}/etc/systemd/system/${UNIT_FILE}"
			fi
		done

		${systemctl} daemon-reload
	fi

	# Remove stopped container
	scmi_docker_terminate

	printf -- \
		"${PREFIX_SUB_STEP_POSITIVE} %s\n" \
		'Uninstall complete'
}

function scmi_usage ()
{
	cat <<-EOF
	Usage: $(basename $0) <COMMAND> [OPTIONS]
	       $(basename $0) [{-h|--help}]

	SCMI simplifes the creation and removal of docker container instances.

	Commands:
	  -i, install                Install, create and start the container and any 
	                             supporting files. If the named container exists 
	                             it will be stopped and removed (terminated).
	  -u, uninstall              Terminate and uninstall the container and any 
	                             supporting files.
	Options:
	  -h, --help                 Show this help and exit.
	  -c, --chroot=CHROOT_PATH   Set the chroot path to run commands. Use when 
	                             running from a container where the docker host's 
	                             root directory is set as a volume mount.
	  -m, --manager=MANAGER      Container manager (docker, systemd) defaults to 
	                             docker.
	  -n, --name=NAME            Container name. The required format is as follows
	                             where <instance> and <node> are required numeric
	                             values. 
	                             {<name>|<name>.[group]}.<instance>.<node>
	  -r, --register             If manager is set to systemd use this to enable 
	                             the optional etcd registration service.
	  --setopt="OPTION VALUE"    Append options to the default docker create 
	                             template. This option can be repeated.
	  -t, --tag=TAG              The docker image tag to use. Defaults to latest.
	EOF

	exit 1
}

scmi "${@}"
