#!/usr/bin/env bash

source /etc/sshd-bootstrap.conf

get_password ()
{
	local PASSWORD_LENGTH=${1:-8}
	local PASSWORD=$(
		head -n 4096 /dev/urandom 2> /dev/null | \
		tr -cd '[:alnum:]' 2> /dev/null | \
		head -c ${PASSWORD_LENGTH} 2> /dev/null
	)

	printf -- "%s" "${PASSWORD}"

	return 0
}

is_sudo_no_password_all ()
{
	local SUDO=${1}

	if [[ -z ${SUDO} ]]; then
		return 1
	fi

	if [[ -n $(echo "${SUDO}" | awk -v pattern="NOPASSWD:ALL" '$NF ~ pattern { print $0; }') ]]; then
		return 0
	fi

	return 1
}

is_valid_ssh_authorized_keys ()
{
	local AUTHORIZED_KEYS="${1:-}"
	local IFS=
	local INVALID_KEY_PATTERN='^/dev/stdin is not a public key file.$'
	local SSH_KEY=

	if [[ -z ${AUTHORIZED_KEYS} ]]; then
		return 1
	fi

	while read -r SSH_KEY || [[ -n ${SSH_KEY} ]]; do
		if [[ -n ${SSH_KEY} ]] && [[ $(get_ssh_key_fingerprint "${SSH_KEY}") =~ ${INVALID_KEY_PATTERN} ]]; then
			return 1
		fi
	done <<< "${AUTHORIZED_KEYS}"

	return 0
}

is_valid_ssh_shell ()
{
	local SHELL=${1}
	local VALID_SHELL=
	local VALID_SHELLS=$(chsh --list-shells)

	if [[ -z ${SHELL} ]]; then
		return 1
	fi

	for VALID_SHELL in ${VALID_SHELLS}; do
		if [[ ${VALID_SHELL} == ${SHELL} ]]; then
			return 0
		fi
	done

	return 1
}

is_valid_ssh_user ()
{
	local USERNAME=${1}
	local SAFE_USERNAME='^[a-z_][a-z0-9_-]{0,29}[$a-z0-9_]?$'

	if [[ ${USERNAME} != root ]] && [[ ${USERNAME} =~ ${SAFE_USERNAME} ]]; then
		return 0
	fi

	return 1
}

is_valid_ssh_user_home_dir ()
{
	local HOME_DIRECTORY="${1:-}"
	local SAFE_DIRECTORY='^\/(?!\/|bin|dev|etc|lib|lib64|lost+found|media|proc|root|sbin|srv|sys|tmp|usr).+$'

	if [[ -n $(grep -oP ${SAFE_DIRECTORY} <<< ${HOME_DIRECTORY}) ]]; then
		return 0
	fi

	return 1
}

is_valid_ssh_user_password_hash ()
{
	local PASSWORD_HASH="${1:-}"
	local SHA_512_PATTERN='^\$6\$[a-zA-Z0-9./]{0,16}\$[a-zA-Z0-9./]{86}$'

	if [[ -z ${PASSWORD_HASH} ]]; then
		return 1
	fi

	if [[ ${PASSWORD_HASH} =~ ${SHA_512_PATTERN} ]]; then
		return 0
	fi

	return 1
}

get_ssh_authorized_keys ()
{
	local DEFAULT_PATH="${1:-/etc/services-config/ssh/authorized_keys}"
	local VALUE="${SSH_AUTHORIZED_KEYS:-}"

	if [[ -z ${VALUE} ]] && [[ -s ${DEFAULT_PATH} ]]; then
		VALUE="$(cat ${DEFAULT_PATH})"
	fi

	printf -- "%s" "${VALUE}"
}

get_ssh_authorized_key_fingerprints ()
{
	local AUTHORIZED_KEYS="${1:-$(get_ssh_authorized_keys)}"
	local FINGERPRINT=
	local FINGERPRINTS=
	local IFS=
	local INVALID_KEY_PATTERN='^/dev/stdin is not a public key file.$'
	local INSECURE_FINGERPRINT='dd:3b:b8:2e:85:04:06:e9:ab:ff:a8:0a:c0:04:6e:d6'
	local SSH_KEY=

	if [[ -z ${AUTHORIZED_KEYS} ]]; then
		return 1
	fi

	while read -r SSH_KEY || [[ -n ${SSH_KEY} ]]; do
		if [[ -n ${SSH_KEY} ]] && [[ ! $(get_ssh_key_fingerprint ${SSH_KEY}) =~ ${INVALID_KEY_PATTERN} ]]; then
			FINGERPRINT=$(
				printf -- '%s' \
				$(get_ssh_key_fingerprint ${SSH_KEY}) | \
				awk '{ print $2; }'
			)

			# Indicate use of insecure public key
			if [[ ${FINGERPRINT} == ${INSECURE_FINGERPRINT} ]];then
				FINGERPRINT+=" (insecure key)"
			fi

			printf -v FINGERPRINTS \
				'%s%s\n' \
				"${FINGERPRINTS}" \
				"${FINGERPRINT}"
		fi
	done <<< "${AUTHORIZED_KEYS}"

	printf -- "%s" "${FINGERPRINTS}"
}

get_ssh_key_fingerprint ()
{
	local SSH_KEY="${1:-}"
	local FINGERPRINT=$(
		ssh-keygen -lf /dev/stdin <<< ${SSH_KEY}
	)

	printf -- "%s" "${FINGERPRINT}"
}

get_ssh_user ()
{
	local DEFAULT_VALUE="${1:-app-admin}"
	local VALUE="${SSH_USER:-}"

	if [[ -z ${VALUE} ]] || ! is_valid_ssh_user "${VALUE}"; then
		VALUE="${DEFAULT_VALUE}"
	fi

	printf "%s" "${VALUE}"
}

get_ssh_user_shell ()
{
	local DEFAULT_VALUE="${1:-/bin/bash}"
	local VALUE="${SSH_USER_SHELL:-}"
	local FORCE_SFTP=${SSH_USER_FORCE_SFTP:-false}

	if [[ -z ${VALUE} ]] || ! is_valid_ssh_shell "${VALUE}"; then
		VALUE="${DEFAULT_VALUE}"
	fi

	# SFTP users cannot have shell access
	if [[ ${FORCE_SFTP} == true ]]; then
		VALUE=/sbin/nologin
	fi

	printf "%s" "${VALUE}"
}

get_ssh_user_home_dir ()
{
	local DEFAULT_VALUE="${1:-/home/$(get_ssh_user)}"
	local VALUE="${SSH_USER_HOME_DIR:-}"

	if [[ -z ${VALUE} ]] || ! is_valid_ssh_user_home_dir "${VALUE}"; then
		VALUE="${DEFAULT_VALUE}"
	fi

	printf "%s" "${VALUE}"
}

generate_new_ssh_host_key ()
{
	local TYPE=${1:-rsa}
	local REPLACE=${2:-false}
	local RESPONSE='n\n'

	if [[ ${REPLACE} == true ]] || [[ ${REPLACE} == 'y' ]]; then
		RESPONSE='y\n'
	fi

	case ${TYPE} in
		rsa|dsa|ecdsa|ed25519)

			echo -e ${RESPONSE} | ssh-keygen \
				-q \
				-C "" \
				-N "" \
				-t ${TYPE} \
				-f /etc/ssh/ssh_host_${TYPE}_key \
				&> /dev/null

			if [[ -x /sbin/restorecon ]]; then
				/sbin/restorecon /etc/ssh/ssh_host_${TYPE}_key.pub
			fi

			;;
		*)
			echo "Unknown key type ${TYPE} - skipping."
			;;
	esac
}

generate_ssh_host_keys ()
{
	local VERSION="${1:-}"

	if [[ -z ${VERSION} ]] && [[ -e /etc/redhat-release ]]; then
		VERSION=$(rpm -q --whatprovides redhat-release --queryformat "%{VERSION}")
	else
		echo "ERROR: Unknown EL release."
		return 1
	fi

	case ${VERSION} in
		6)
			generate_new_ssh_host_key rsa true
			generate_new_ssh_host_key dsa true
			;;
		7)
			generate_new_ssh_host_key rsa true
			generate_new_ssh_host_key dsa true
			generate_new_ssh_host_key ecdsa true
			generate_new_ssh_host_key ed25519 true
			;;
		*)
			echo "Unknown EL release ${VERSION} - skipping."
			;;
	esac
}

OPTS_SSH_INHERIT_ENVIRONMENT=${SSH_INHERIT_ENVIRONMENT:-false}
OPTS_SSH_USER="$(get_ssh_user app-admin)"
OPTS_SSH_USER_HOME_DIR="$(get_ssh_user_home_dir /home/${OPTS_SSH_USER})"

# Docker ENV inheritance
if [[ ${OPTS_SSH_INHERIT_ENVIRONMENT} == true ]] && [[ -s /etc/sshd-bootstrap.env ]]; then
	# Variables to exclude
	grep -Ev "^([.]*SSH_USER_PASSWORD|_|HOME|HOSTNAME|PATH|PWD|SHLVL|SUPERVISOR_ENABLED|SUPERVISOR_GROUP_NAME|SUPERVISOR_PROCESS_NAME|TERM)=" \
		/etc/sshd-bootstrap.env > /etc/environment
fi

if [[ ! -d ${OPTS_SSH_USER_HOME_DIR}/.ssh ]]; then

	# Allow some time for supervisor_stdout to start
	sleep 2 &
	TIMEOUT_PID=${!}

	DEFAULT_SSH_SUDO="ALL=(ALL) ALL"
	PASSWORD_LENGTH=16
	REDACTED_VALUE="********"
	OPTS_SSH_AUTHORIZED_KEYS="$(get_ssh_authorized_keys /etc/services-config/ssh/authorized_keys)"
	OPTS_SSH_SUDO="${SSH_SUDO:-${DEFAULT_SSH_SUDO}}"
	OPTS_SSH_USER_PASSWORD_HASHED="${SSH_USER_PASSWORD_HASHED:-false}"
	OPTS_SSH_USER_PASSWORD="${SSH_USER_PASSWORD:-$(get_password ${PASSWORD_LENGTH})}"
	OPTS_SSH_USER_FORCE_SFTP=${SSH_USER_FORCE_SFTP:-false}
	OPTS_SSH_USER_SHELL="$(get_ssh_user_shell /bin/bash)"

	# SFTP users setup
	OPTS_CHROOT_DIRECTORY=/chroot
	if [[ ${OPTS_SSH_USER_FORCE_SFTP} == true ]]; then
		SSH_USER_GROUPS=users
		SSHD_COMMAND=SFTP
	else
		SSHD_COMMAND=SSH
	fi

	# Initialise
	echo "Initialising ${SSHD_COMMAND}."

	# Generate new host keys
	generate_ssh_host_keys

	useradd \
		-u 500 \
		-m \
		-G ${SSH_USER_GROUPS:-users,wheel} \
		-d ${OPTS_SSH_USER_HOME_DIR} \
		-s ${OPTS_SSH_USER_SHELL} \
		${OPTS_SSH_USER}

	# SFTP users
	if [[ ${OPTS_SSH_USER_FORCE_SFTP} == true ]]; then
		SSHD_COMMAND=SFTP

		if [[ -n ${OPTS_CHROOT_DIRECTORY} ]] && [[ ! -d ${OPTS_CHROOT_DIRECTORY} ]]; then 
			mkdir -m 711 ${OPTS_CHROOT_DIRECTORY}
			mkdir -p -m 755 ${OPTS_CHROOT_DIRECTORY}${OPTS_SSH_USER_HOME_DIR}
		else
			chmod 755 ${OPTS_CHROOT_DIRECTORY}${OPTS_SSH_USER_HOME_DIR}
		fi

		chown -R ${OPTS_SSH_USER}:${OPTS_SSH_USER} ${OPTS_CHROOT_DIRECTORY}/*

		# Add group specific sshd configuration 
		tee -a /etc/ssh/sshd_config > /dev/null <<-EOT
			# Force SFTP
			Match group ${SSH_USER_GROUPS}
			AllowTcpForwarding no
			X11Forwarding no
			PasswordAuthentication yes
			ChrootDirectory ${OPTS_CHROOT_DIRECTORY}
			ForceCommand internal-sftp
		EOT
	else
		sed -i \
			-e '/# Force SFTP/,/ForceCommand internal-sftp/ { d; }' \
			/etc/ssh/sshd_config
	fi

	# SSH require files
	mkdir -m 700 ${OPTS_SSH_USER_HOME_DIR}/.ssh
	touch ${OPTS_SSH_USER_HOME_DIR}/.ssh/authorized_keys
	chown -R ${OPTS_SSH_USER}:${OPTS_SSH_USER} ${OPTS_SSH_USER_HOME_DIR}/.ssh
	chmod 600 ${OPTS_SSH_USER_HOME_DIR}/.ssh/authorized_keys

	if ! is_valid_ssh_authorized_keys "${OPTS_SSH_AUTHORIZED_KEYS}"; then
		printf -v SSH_KEY_FINGERPRINTS \
			'ERROR: Public key validation failed.\nUnable to populate %s/.ssh/authorized_key\n' \
			"${OPTS_SSH_USER_HOME_DIR}"
	else
		printf "%s" "${OPTS_SSH_AUTHORIZED_KEYS}" > ${OPTS_SSH_USER_HOME_DIR}/.ssh/authorized_keys
		SSH_KEY_FINGERPRINTS="$(get_ssh_authorized_key_fingerprints)"
	fi

	# Set sudo access for the wheel group only
	if [[ ${DEFAULT_SSH_SUDO} != ${OPTS_SSH_SUDO} ]]; then
		sed -i "s~^%wheel\\t.*$~%wheel\\t${OPTS_SSH_SUDO}~g" /etc/sudoers
	fi

	tee -a /etc/sudoers > /dev/null <<-EOT

		# ${OPTS_SSH_USER}
		Defaults:root secure_path = /sbin:/bin:/usr/sbin:/usr/bin:/usr/local/bin
	EOT

	# Set root user password
	echo "root:${SSH_ROOT_PASSWORD:-$(get_password ${PASSWORD_LENGTH})}" | chpasswd

	# Never store the root password
	SSH_ROOT_PASSWORD=${REDACTED_VALUE}

	# Set SSH user password
	if [[ ${OPTS_SSH_USER_PASSWORD_HASHED} == true ]] && [[ -n ${SSH_USER_PASSWORD} ]]; then
		# Hashed password must use SHA-512 hashing algorithm
		if ! is_valid_ssh_user_password_hash "${SSH_USER_PASSWORD}"; then
			echo "ERROR: Password hash not SHA-512 - setting new password."

			SSH_USER_PASSWORD=
			OPTS_SSH_USER_PASSWORD=$(get_password ${PASSWORD_LENGTH})
			echo "${OPTS_SSH_USER}:${OPTS_SSH_USER_PASSWORD}" | chpasswd
		else
			echo "${OPTS_SSH_USER}:${SSH_USER_PASSWORD}" | chpasswd -e
		fi
	else 
		echo "${OPTS_SSH_USER}:${OPTS_SSH_USER_PASSWORD}" | chpasswd
	fi

	# Only show user password if auto-generated and password is required for sudo
	if [[ -n ${SSH_USER_PASSWORD} ]] || is_sudo_no_password_all "${OPTS_SSH_SUDO}"; then
		OPTS_SSH_USER_PASSWORD=${REDACTED_VALUE}
		SSH_USER_PASSWORD=${REDACTED_VALUE}
	fi

	cat <<-EOT

		================================================================================
		${SSHD_COMMAND} Credentials
		--------------------------------------------------------------------------------
		user : ${OPTS_SSH_USER}
		password : ${OPTS_SSH_USER_PASSWORD}
		sudo : ${OPTS_SSH_SUDO}
		key fingerprints : 
		${SSH_KEY_FINGERPRINTS}
		--------------------------------------------------------------------------------
		
	EOT

	wait ${TIMEOUT_PID}
fi

exit 0